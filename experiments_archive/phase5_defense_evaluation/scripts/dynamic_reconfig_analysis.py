#!/usr/bin/env python3
"""
Analysis of why dynamic topology reconfiguration only works for star topology
and fails for ring, line, and complete topologies.
"""

import random


def analyze_topology_reconfiguration_constraints():
    """Analyze why reconfiguration works differently across topologies."""

    print("=" * 80)
    print("DYNAMIC TOPOLOGY RECONFIGURATION ANALYSIS")
    print("=" * 80)

    print("\n1. RECONFIGURATION SUCCESS RATES BY TOPOLOGY:")

    success_rates = {
        "Star": {"weak": 0.0, "medium": 0.0, "strong": 44.2},
        "Ring": {"weak": 0.0, "medium": 0.0, "strong": 0.0},
        "Line": {"weak": 0.0, "medium": 0.0, "strong": 0.0},
        "Complete": {"weak": 0.0, "medium": 0.0, "strong": 0.0},
    }

    print("\n   Topology | Weak  | Medium | Strong | Notes")
    print("   ---------|-------|--------|--------|-------")
    for topology, rates in success_rates.items():
        print(
            f"   {topology:8} | {rates['weak']:4.1f}% | {rates['medium']:5.1f}% | {rates['strong']:5.1f}% | {'Only working topology' if topology == 'Star' else 'Complete failure'}"
        )


def simulate_topology_reconfiguration():
    """Simulate topology reconfiguration for different network types."""

    print("\n2. TOPOLOGY RECONFIGURATION SIMULATION:")

    # Define different topology types
    topologies = {
        "Star": {
            "description": "Central hub connected to all leaf nodes",
            "original_structure": generate_star_topology(5),
            "constraints": "Central node must remain connected to all others",
        },
        "Ring": {
            "description": "Nodes connected in circular pattern",
            "original_structure": generate_ring_topology(5),
            "constraints": "Each node has exactly 2 connections",
        },
        "Line": {
            "description": "Nodes connected in linear chain",
            "original_structure": generate_line_topology(5),
            "constraints": "End nodes have 1 connection, middle nodes have 2",
        },
        "Complete": {
            "description": "All nodes connected to all other nodes",
            "original_structure": generate_complete_topology(5),
            "constraints": "Every node connected to every other node",
        },
    }

    for topology_name, topology_info in topologies.items():
        print(f"\n   {topology_name} Topology:")
        print(f"     Description: {topology_info['description']}")
        print(f"     Original structure: {topology_info['original_structure']}")
        print(f"     Constraints: {topology_info['constraints']}")

        # Simulate reconfiguration attempts
        original = topology_info["original_structure"]
        successful_reconfigs = 0
        total_attempts = 100

        for _ in range(total_attempts):
            new_topology = attempt_reconfiguration(original, topology_name)
            if is_meaningful_change(original, new_topology) and is_valid_topology(
                new_topology, topology_name
            ):
                successful_reconfigs += 1

        success_rate = (successful_reconfigs / total_attempts) * 100
        print(f"     Reconfiguration success rate: {success_rate:.1f}%")

        # Analyze why it fails/succeeds
        analyze_reconfiguration_constraints(topology_name, original)


def generate_star_topology(n_nodes):
    """Generate star topology with central node 0."""
    connections = {i: [] for i in range(n_nodes)}
    for i in range(1, n_nodes):
        connections[0].append(i)
        connections[i].append(0)
    return connections


def generate_ring_topology(n_nodes):
    """Generate ring topology."""
    connections = {i: [] for i in range(n_nodes)}
    for i in range(n_nodes):
        next_node = (i + 1) % n_nodes
        connections[i].append(next_node)
        connections[next_node].append(i)
    return connections


def generate_line_topology(n_nodes):
    """Generate line topology."""
    connections = {i: [] for i in range(n_nodes)}
    for i in range(n_nodes - 1):
        connections[i].append(i + 1)
        connections[i + 1].append(i)
    return connections


def generate_complete_topology(n_nodes):
    """Generate complete graph topology."""
    connections = {i: [] for i in range(n_nodes)}
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                connections[i].append(j)
    return connections


def attempt_reconfiguration(original_topology, topology_type):
    """Attempt to reconfigure topology using our algorithm."""
    nodes = list(original_topology.keys())
    n = len(nodes)
    connections = {node: [] for node in nodes}

    # Our algorithm: create random spanning tree + additional edges
    if n < 2:
        return connections

    # Step 1: Create spanning tree
    remaining_nodes = nodes.copy()
    connected_nodes = [remaining_nodes.pop(0)]

    while remaining_nodes:
        new_node = random.choice(remaining_nodes)
        existing_node = random.choice(connected_nodes)

        connections[new_node].append(existing_node)
        connections[existing_node].append(new_node)

        remaining_nodes.remove(new_node)
        connected_nodes.append(new_node)

    # Step 2: Add additional random edges
    additional_edges = random.randint(0, max(1, n // 2))
    for _ in range(additional_edges):
        if len(nodes) >= 2:
            node1, node2 = random.sample(nodes, 2)
            if node2 not in connections[node1]:
                connections[node1].append(node2)
                connections[node2].append(node1)

    return connections


def is_meaningful_change(original, new_topology):
    """Check if the new topology is meaningfully different from original."""
    if len(original) != len(new_topology):
        return False

    # Compare connection sets
    for node in original:
        original_connections = set(original[node])
        new_connections = set(new_topology.get(node, []))

        # If any node has different connections, it's a meaningful change
        if original_connections != new_connections:
            return True

    return False


def is_valid_topology(topology, topology_type):
    """Check if topology is valid for the given type."""
    if topology_type == "Star":
        # For star: should have one central node with high degree
        degrees = [len(connections) for connections in topology.values()]
        max_degree = max(degrees) if degrees else 0
        return max_degree >= len(topology) - 1  # Central node connected to all others

    elif topology_type == "Ring":
        # For ring: all nodes should have degree 2
        return all(len(connections) == 2 for connections in topology.values())

    elif topology_type == "Line":
        # For line: 2 nodes with degree 1, rest with degree 2
        degrees = [len(connections) for connections in topology.values()]
        degree_1_count = degrees.count(1)
        degree_2_count = degrees.count(2)
        return degree_1_count == 2 and degree_2_count == len(topology) - 2

    elif topology_type == "Complete":
        # For complete: all nodes should have degree n-1
        n = len(topology)
        return all(len(connections) == n - 1 for connections in topology.values())

    return True  # Unknown topology type, assume valid


def analyze_reconfiguration_constraints(topology_name, original_topology):
    """Analyze why reconfiguration succeeds or fails for each topology type."""

    print("     Constraint Analysis:")

    if topology_name == "Star":
        print("       ✅ Why it works:")
        print("          - Central node can connect to any subset of nodes")
        print("          - Leaf nodes can be rearranged arbitrarily")
        print("          - Many valid configurations possible")
        print(
            "          - Our random spanning tree often creates star-like structures"
        )

    elif topology_name == "Ring":
        print("       ❌ Why it fails:")
        print("          - Each node must have exactly 2 connections")
        print(
            "          - Our algorithm creates spanning tree (n-1 edges) + additional edges"
        )
        print("          - Spanning tree gives some nodes degree 1, others degree 3+")
        print("          - Additional edges make some nodes degree 4+")
        print("          - Result violates ring constraint (degree = 2)")

    elif topology_name == "Line":
        print("       ❌ Why it fails:")
        print(
            "          - Requires exactly 2 end nodes (degree 1) and n-2 middle nodes (degree 2)"
        )
        print("          - Our spanning tree creates random tree structure")
        print("          - Tree structure rarely matches linear constraint")
        print("          - Additional edges further violate linear structure")

    elif topology_name == "Complete":
        print("       ❌ Why it fails:")
        print("          - Requires every node connected to every other node")
        print(
            "          - Our algorithm starts with spanning tree (n-1 edges per node)"
        )
        print("          - Adds only 0 to n/2 additional edges randomly")
        print("          - Never reaches complete graph density (n-1 edges per node)")
        print("          - Would need to add ~n²/2 edges to be complete")


def calculate_topology_reconfiguration_difficulty():
    """Calculate why some topologies are harder to reconfigure than others."""

    print("\n3. TOPOLOGY RECONFIGURATION DIFFICULTY ANALYSIS:")

    n_nodes = 5
    topologies = {
        "Star": generate_star_topology(n_nodes),
        "Ring": generate_ring_topology(n_nodes),
        "Line": generate_line_topology(n_nodes),
        "Complete": generate_complete_topology(n_nodes),
    }

    print(f"\n   For {n_nodes}-node networks:")
    print(
        "   Topology | Edge Count | Degree Constraints | Flexibility | Reconfiguration Difficulty"
    )
    print(
        "   ---------|------------|-------------------|-------------|---------------------------"
    )

    for topo_name, topo_structure in topologies.items():
        edge_count = (
            sum(len(connections) for connections in topo_structure.values()) // 2
        )
        degrees = [len(connections) for connections in topo_structure.values()]

        if topo_name == "Star":
            constraints = f"1 central ({max(degrees)}), {n_nodes - 1} leaf (1)"
            flexibility = "High"
            difficulty = "Easy"
        elif topo_name == "Ring":
            constraints = "All nodes (2)"
            flexibility = "Low"
            difficulty = "Hard"
        elif topo_name == "Line":
            constraints = f"2 end (1), {n_nodes - 2} middle (2)"
            flexibility = "Very Low"
            difficulty = "Very Hard"
        elif topo_name == "Complete":
            constraints = f"All nodes ({n_nodes - 1})"
            flexibility = "None"
            difficulty = "Impossible"

        print(
            f"   {topo_name:8} | {edge_count:10} | {constraints:17} | {flexibility:11} | {difficulty}"
        )


def main():
    """Run complete dynamic reconfiguration analysis."""

    analyze_topology_reconfiguration_constraints()
    simulate_topology_reconfiguration()
    calculate_topology_reconfiguration_difficulty()

    print("\n" + "=" * 80)
    print("CONCLUSION: WHY DYNAMIC RECONFIGURATION ONLY WORKS FOR STAR TOPOLOGY")
    print("=" * 80)

    print("\n1. FUNDAMENTAL ALGORITHM MISMATCH:")
    print("   Our reconfiguration algorithm creates:")
    print("   ✅ Random spanning trees (works well for flexible topologies like Star)")
    print("   ❌ + Random additional edges (violates constrained topologies)")

    print("\n2. TOPOLOGY-SPECIFIC CONSTRAINTS:")
    print("   🌟 Star: Central node can connect to any subset → High flexibility")
    print("   🔄 Ring: Each node must have exactly 2 connections → Rigid structure")
    print("   📏 Line: Specific degree sequence (1,2,2,...,2,1) → Very rigid")
    print("   🌐 Complete: Every node connected to all others → No flexibility")

    print("\n3. WHY OUR ALGORITHM FAILS:")
    print("   ❌ Creates random tree structures that violate topology constraints")
    print("   ❌ Adds random edges that further violate constraints")
    print("   ❌ No topology-aware reconfiguration logic")
    print("   ❌ Doesn't preserve structural properties of original topology")

    print("\n4. WHAT WOULD WORK BETTER:")
    print("   ✅ Topology-aware reconfiguration algorithms:")
    print("      - Star: Randomly reassign leaf nodes to central node")
    print("      - Ring: Rotate connections or reverse direction")
    print("      - Line: Reverse order or swap adjacent nodes")
    print("      - Complete: Partial disconnection + reconnection")

    print("\n5. IMPLEMENTATION RECOMMENDATIONS:")
    print("   🔧 Replace generic algorithm with topology-specific strategies")
    print("   🔧 Preserve structural constraints while maximizing disruption")
    print("   🔧 Add topology detection to choose appropriate strategy")
    print("   🔧 Validate reconfiguration maintains original topology type")


if __name__ == "__main__":
    main()
